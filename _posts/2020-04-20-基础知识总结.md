---
title: 基础知识总结
description: Java
categories:
 - interview
tags:
---

<!-- more -->



### 一、Spring
#### 1.1 spring bean的生命周期
https://www.jianshu.com/p/1dec08d290c1
beanFactoryPostProcessoer 动态代理 FactoryBean https://www.cnblogs.com/piepie/p/9061076.html

Spring Bean的生命周期是Spring面试热点问题。这个问题即考察对Spring的微观了解，又考察对Spring的宏观认识，想要答好并不容易！本文希望能够从源码角度入手，帮助面试者彻底搞定Spring Bean的生命周期。
只有四个！
是的，Spring Bean的生命周期只有这四个阶段。把这四个阶段和每个阶段对应的扩展点糅合在一起虽然没有问题，但是这样非常凌乱，难以记忆。要彻底搞清楚Spring的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应构造方法和setter方法的注入，初始化和销毁是用户能自定义扩展的两个阶段。在这四步之间穿插的各种扩展点，稍后会讲。
1.	实例化 Instantiation
2.	属性赋值 Populate
3.	初始化 Initialization
4.	销毁 Destruction
实例化 -> 属性赋值 -> 初始化 -> 销毁
	主要逻辑都在doCreate()方法中，逻辑很清晰，就是顺序调用以下三个方法，这三个方法与三个生命周期阶段一一对应，非常重要，在后续扩展接口分析中也会涉及。
1.	createBeanInstance() -> 实例化
2.	populateBean() -> 属性赋值
3.	initializeBean() -> 初始化
	源码如下，能证明实例化，属性赋值和初始化这三个生命周期的存在。关于本文的Spring源码都将忽略无关部分，便于理解：
// 忽略了无关代码
protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
      throws BeanCreationException {

   // Instantiate the bean.
   BeanWrapper instanceWrapper = null;
   if (instanceWrapper == null) {
       // 实例化阶段！
      instanceWrapper = createBeanInstance(beanName, mbd, args);
   }

   // Initialize the bean instance.
   Object exposedObject = bean;
   try {
       // 属性赋值阶段！
      populateBean(beanName, mbd, instanceWrapper);
       // 初始化阶段！
      exposedObject = initializeBean(beanName, exposedObject, mbd);
   }

   
   }
至于销毁，是在容器关闭时调用的，详见ConfigurableApplicationContext#close()
常用扩展点
Spring生命周期相关的常用扩展点非常多，所以问题不是不知道，而是记不住或者记不牢。其实记不住的根本原因还是不够了解，这里通过源码+分类的方式帮大家记忆。
第一大类：影响多个Bean的接口
实现了这些接口的Bean会切入到多个Bean的生命周期中。正因为如此，这些接口的功能非常强大，Spring内部扩展也经常使用这些接口，例如自动注入以及AOP的实现都和他们有关。
•	BeanPostProcessor
•	InstantiationAwareBeanPostProcessor
这两兄弟可能是Spring扩展中最重要的两个接口！InstantiationAwareBeanPostProcessor作用于实例化阶段的前后，BeanPostProcessor作用于初始化阶段的前后。正好和第一、第三个生命周期阶段对应。通过图能更好理解：

InstantiationAwareBeanPostProcessor实际上继承了BeanPostProcessor接口，严格意义上来看他们不是两兄弟，而是两父子。但是从生命周期角度我们重点关注其特有的对实例化阶段的影响，图中省略了从BeanPostProcessor继承的方法。
InstantiationAwareBeanPostProcessor extends BeanPostProcessor
InstantiationAwareBeanPostProcessor源码分析：
•	postProcessBeforeInstantiation调用点，忽略无关代码：
@Override
    protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
            throws BeanCreationException {

        try {
            // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
            // postProcessBeforeInstantiation方法调用点，这里就不跟进了，
            // 有兴趣的同学可以自己看下，就是for循环调用所有的InstantiationAwareBeanPostProcessor
            Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
            if (bean != null) {
                return bean;
            }
        }
        
        try {   
            // 上文提到的doCreateBean方法，可以看到
            // postProcessBeforeInstantiation方法在创建Bean之前调用
            Object beanInstance = doCreateBean(beanName, mbdToUse, args);
            if (logger.isTraceEnabled()) {
                logger.trace("Finished creating instance of bean '" + beanName + "'");
            }
            return beanInstance;
        }
        
    }

可以看到，postProcessBeforeInstantiation在doCreateBean之前调用，也就是在bean实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的Bean作为代理，这也是Aop等功能实现的关键点。
•	postProcessAfterInstantiation调用点，忽略无关代码：
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {

   // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
   // state of the bean before properties are set. This can be used, for example,
   // to support styles of field injection.
   boolean continueWithPropertyPopulation = true;
    // InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation()
    // 方法作为属性赋值的前置检查条件，在属性赋值之前执行，能够影响是否进行属性赋值！
   if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
      for (BeanPostProcessor bp : getBeanPostProcessors()) {
         if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
               continueWithPropertyPopulation = false;
               break;
            }
         }
      }
   }

   // 忽略后续的属性赋值操作代码
}
可以看到该方法在属性赋值方法内，但是在真正执行赋值操作之前。其返回值为boolean，返回false时可以阻断属性赋值阶段（continueWithPropertyPopulation = false;）。
关于BeanPostProcessor执行阶段的源码穿插在下文Aware接口的调用时机分析中，因为部分Aware功能的就是通过他实现的!只需要先记住BeanPostProcessor在初始化前后调用就可以了。
第二大类：只调用一次的接口
这一大类接口的特点是功能丰富，常用于用户自定义扩展。 第二大类中又可以分为两类：
1.	Aware类型的接口
2.	生命周期接口
无所不知的Aware
Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源。基本都能够见名知意，Aware之前的名字就是可以拿到什么资源，例如BeanNameAware可以拿到BeanName，以此类推。调用时机需要注意：所有的Aware方法都是在初始化阶段之前调用的！ Aware接口众多，这里同样通过分类的方式帮助大家记忆。 Aware接口具体可以分为两组，至于为什么这么分，详见下面的源码分析。如下排列顺序同样也是Aware接口的执行顺序，能够见名知意的接口不再解释。
Aware Group1
1.	BeanNameAware
2.	BeanClassLoaderAware
3.	BeanFactoryAware
Aware Group2
1.	EnvironmentAware
2.	EmbeddedValueResolverAware 这个知道的人可能不多，实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用，非常方便。
3.	ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware) 这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的ApplicationContext对象，因为ApplicationContext是一个复合接口，如下：
public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,
        MessageSource, ApplicationEventPublisher, ResourcePatternResolver {}
这里涉及到另一道面试题，ApplicationContext和BeanFactory的区别，可以从ApplicationContext继承的这几个接口入手，除去BeanFactory相关的两个接口就是ApplicationContext独有的功能，这里不详细说明。
Aware调用时机源码分析
详情如下，忽略了部分无关代码。代码位置就是我们上文提到的initializeBean方法详情，这也说明了Aware都是在初始化阶段之前调用的！
    // 见名知意，初始化阶段调用的方法
    protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {

        // 这里调用的是Group1中的三个Bean开头的Aware
        invokeAwareMethods(beanName, bean);

        Object wrappedBean = bean;
        
        // 这里调用的是Group2中的几个Aware，
        // 而实质上这里就是前面所说的BeanPostProcessor的调用点！
        // 也就是说与Group1中的Aware不同，这里是通过BeanPostProcessor（ApplicationContextAwareProcessor）实现的。
        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
        // 下文即将介绍的InitializingBean调用点
        invokeInitMethods(beanName, wrappedBean, mbd);
        // BeanPostProcessor的另一个调用点
        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);

        return wrappedBean;
    }
可以看到并不是所有的Aware接口都使用同样的方式调用。Bean××Aware都是在代码中直接调用的，而ApplicationContext相关的Aware都是通过BeanPostProcessor#postProcessBeforeInitialization()实现的。感兴趣的可以自己看一下ApplicationContextAwareProcessor这个类的源码，就是判断当前创建的Bean是否实现了相关的Aware方法，如果实现了会调用回调方法将资源传递给Bean。 至于Spring为什么这么实现，应该没什么特殊的考量。也许和Spring的版本升级有关。基于对修改关闭，对扩展开放的原则，Spring对一些新的Aware采用了扩展的方式添加。
BeanPostProcessor的调用时机也能在这里体现，包围住invokeInitMethods方法，也就说明了在初始化阶段的前后执行。
关于Aware接口的执行顺序，其实只需要记住第一组在第二组执行之前就行了。每组中各个Aware方法的调用顺序其实没有必要记，有需要的时候点进源码一看便知。
简单的两个生命周期接口
至于剩下的两个生命周期接口就很简单了，实例化和属性赋值都是Spring帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段。
1.	InitializingBean 对应生命周期的初始化阶段，在上面源码的invokeInitMethods(beanName, wrappedBean, mbd);方法中调用。 有一点需要注意，因为Aware方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用Aware接口获取的资源，这也是我们自定义扩展Spring的常用方式。 除了实现InitializingBean接口之外还能通过注解或者xml配置的方式指定初始化方法，至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式。
2.	DisposableBean 类似于InitializingBean，对应生命周期的销毁阶段，以ConfigurableApplicationContext#close()方法作为入口，实现是通过循环取所有实现了DisposableBean接口的Bean然后调用其destroy()方法 。感兴趣的可以自行跟一下源码。
扩展阅读: BeanPostProcessor 注册时机与执行顺序
注册时机
我们知道BeanPostProcessor也会注册为Bean，那么Spring是如何保证BeanPostProcessor在我们的业务Bean之前初始化完成呢？ 请看我们熟悉的refresh()方法的源码，省略部分无关代码：
@Override
    public void refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {

            try {
                // Allows post-processing of the bean factory in context subclasses.
                postProcessBeanFactory(beanFactory);

                // Invoke factory processors registered as beans in the context.
                invokeBeanFactoryPostProcessors(beanFactory);

                // Register bean processors that intercept bean creation.
                // 所有BeanPostProcesser初始化的调用点
                registerBeanPostProcessors(beanFactory);

                // Initialize message source for this context.
                initMessageSource();

                // Initialize event multicaster for this context.
                initApplicationEventMulticaster();

                // Initialize other special beans in specific context subclasses.
                onRefresh();

                // Check for listener beans and register them.
                registerListeners();

                // Instantiate all remaining (non-lazy-init) singletons.
                // 所有单例非懒加载Bean的调用点
                finishBeanFactoryInitialization(beanFactory);

                // Last step: publish corresponding event.
                finishRefresh();
            }

    }
可以看出，Spring是先执行registerBeanPostProcessors()进行BeanPostProcessors的注册，然后再执行finishBeanFactoryInitialization初始化我们的单例非懒加载的Bean。
执行顺序
BeanPostProcessor有很多个，而且每个BeanPostProcessor都影响多个Bean，其执行顺序至关重要，必须能够控制其执行顺序才行。关于执行顺序这里需要引入两个排序相关的接口：PriorityOrdered、Ordered
•	PriorityOrdered是一等公民，首先被执行，PriorityOrdered公民之间通过接口返回值排序 
•	Ordered是二等公民，然后执行，Ordered公民之间通过接口返回值排序 
•	都没有实现是三等公民，最后执行 
在以下源码中，可以很清晰的看到Spring注册各种类型BeanPostProcessor的逻辑，根据实现不同排序接口进行分组。优先级高的先加入，优先级低的后加入。
// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
// 首先，加入实现了PriorityOrdered接口的BeanPostProcessors，顺便根据PriorityOrdered排了序
            String[] postProcessorNames =
                    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            for (String ppName : postProcessorNames) {
                if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                    processedBeans.add(ppName);
                }
            }
            sortPostProcessors(currentRegistryProcessors, beanFactory);
            registryProcessors.addAll(currentRegistryProcessors);
            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
            currentRegistryProcessors.clear();

            // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
// 然后，加入实现了Ordered接口的BeanPostProcessors，顺便根据Ordered排了序
            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            for (String ppName : postProcessorNames) {
                if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                    processedBeans.add(ppName);
                }
            }
            sortPostProcessors(currentRegistryProcessors, beanFactory);
            registryProcessors.addAll(currentRegistryProcessors);
            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
            currentRegistryProcessors.clear();

            // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
// 最后加入其他常规的BeanPostProcessors
            boolean reiterate = true;
            while (reiterate) {
                reiterate = false;
                postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
                for (String ppName : postProcessorNames) {
                    if (!processedBeans.contains(ppName)) {
                        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                        processedBeans.add(ppName);
                        reiterate = true;
                    }
                }
                sortPostProcessors(currentRegistryProcessors, beanFactory);
                registryProcessors.addAll(currentRegistryProcessors);
                invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
                currentRegistryProcessors.clear();
            }
根据排序接口返回值排序，默认升序排序，返回值越低优先级越高。
    /**
     * Useful constant for the highest precedence value.
     * @see java.lang.Integer#MIN_VALUE
     */
    int HIGHEST_PRECEDENCE = Integer.MIN_VALUE;

    /**
     * Useful constant for the lowest precedence value.
     * @see java.lang.Integer#MAX_VALUE
     */
    int LOWEST_PRECEDENCE = Integer.MAX_VALUE;
PriorityOrdered、Ordered接口作为Spring整个框架通用的排序接口，在Spring中应用广泛，也是非常重要的接口。
总结
Spring Bean的生命周期分为四个阶段和多个扩展点。扩展点又可以分为影响多个Bean和影响单个Bean。整理如下： 四个阶段
•	实例化 Instantiation
•	属性赋值 Populate
•	初始化 Initialization
•	销毁 Destruction
多个扩展点
•	影响多个Bean
◦	BeanPostProcessor
◦	InstantiationAwareBeanPostProcessor
•	影响单个Bean
◦	Aware
▪	Aware Group1
▪	BeanNameAware
▪	BeanClassLoaderAware
▪	BeanFactoryAware
▪	Aware Group2
▪	EnvironmentAware
▪	EmbeddedValueResolverAware
▪	ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)
◦	生命周期
▪	InitializingBean
▪	DisposableBean
至此，Spring Bean的生命周期介绍完毕

#### 1.2  Springboot 启动

org.springframework.boot.SpringApplication#run(java.lang.Object, java.lang.String…)
//设置java.awt.headless 
org.springframework.boot.SpringApplication#configureHeadlessProperty
//初始化Listener  配置在META-INF/factories   org.springframework.boot.SpringApplication#getRunListeners
（org.springframework.boot.context.event.EventPublishingRunListener）
//监听器启动，发布启动事件
listeners.starting()
//准备环境
org.springframework.boot.SpringApplication#prepareEnvironment
org.springframework.boot.SpringApplication#configureEnvironment
org.springframework.boot.SpringApplication#configurePropertySources
org.springframework.boot.SpringApplication#configureProfiles
//创建ApplicationContext
org.springframework.boot.SpringApplication#createApplicationContext
BeanUtils.instantiate(contextClass)
初始化AnnotationConfigEmbeddedWebApplicationContext
//准备Context
org.springframework.boot.SpringApplication#prepareContext
//做一些初始化工作
org.springframework.boot.context.config.DelegatingApplicationContextInitializer#initialize
实现org.springframework.context.ApplicationContextInitializer
SecurityDefaultPropertyValueApplierApplicationContextInitializer

//加载bean定义  入口以及配置 scan
org.springframework.boot.SpringApplication#createBeanDefinitionLoader

org.springframework.boot.BeanDefinitionLoader#load()
//注册beanDefinition
org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition

org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition


org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition



//
org.springframework.context.support.AbstractApplicationContext#refresh

org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors


org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>)

//beanfactory的初始化后处理
org.springframework.context.support.AbstractApplicationContext#postProcessBeanFactory
//bean的初始化后处理
org.springframework.context.support.AbstractApplicationContext#registerBeanPostProcessors
org.springframework.beans.factory.config.BeanFactoryPostProcessor
org.springframework.beans.factory.config.BeanPostProcessor

#####1.3 spring基本概念
#####1.	为什么需要代理模式？
#####2.	讲讲静态代理模式的优点及其瓶颈？
#####3.	对Java 接口代理模式的实现原理的理解？
#####4.	如何使用 Java 反射实现动态代理？
#####5.	Java 接口代理模式的指定增强？
#####6.	谈谈对Cglib 类增强动态代理的实现？
#####7.	怎么理解面向切面编程的切面？
#####8.	讲解OOP与AOP的简单对比？
#####9.	讲解JDK 动态代理和 CGLIB 代理原理以及区别？
#####10.	讲解Spring 框架中基于 Schema 的 AOP 实现原理？
#####11.	讲解Spring 框架中如何基于 AOP 实现的事务管理？
	附：spring事务失效的原因？
	一、异常
	二、事务是基于动态代理实现，方法必须通过动态代理对象获取才会生效，否则失效。比如 Service的A()调用B()，调用方式为this.B() (或者直接B()) 因为拿到的是实现类而非代理类的B() 所以实际效果相当于把B方法内容嵌入A，而没有走动态代理，需要传入Service.B().  具体bean的方法， Spring的bean都是代理对象，而class里面的this 只是实例本身，而非代理。总的来说，一句话，必须通过spring bean（代理对象）访问的方法才具备事务生效
	见https://www.ixigua.com/i6647798177057473028/
#####12.	谈谈对控制反转的设计思想的理解？
#####13.	怎么理解 Spring IOC 容器？
#####14.	Spring IOC 怎么管理 Bean 之间的依赖关系，怎么避免循环依赖？
	https://my.oschina.net/zhangxufeng/blog/3096394 
		步骤一：beanA进行初始化，并且将自己进行初始化的状态记录下来，并提前向外暴露一个单例工程方法，从而使其他bean能引用到该bean（可能读完这一句，您仍然心存疑惑，没关系，继续往下读）
		步骤二：beanA中有beanB的依赖，于是开始初始化beanB。
	　　步骤三：初始化beanB的过程中又发现beanB依赖了beanA,于是又进行beanA的初始化，这时发现beanA已经在进行初始化了，程序发现了存在的循环依赖，然后通过步骤一中暴露的单例工程方法拿到beanA的引用（注意，此时的beanA只是完成了构造函数的注入但为完成其他步骤），从而beanB拿到beanA的引用，完成注入，完成了初始化，如此beanB的引用也就可以被beanA拿到，从而beanA也就完成了初始化。
	　　spring进行bean的加载的时候，首先进行bean的初始化（调用构造函数），然后进行属性填充。在这两步中间，spring对bean进行了一次状态的记录，也就是说spring会把指向只完成了构造函数初始化的bean的引用通过一个变量记录下来，明白这一点对之后的源码理解至关重要。
	https://www.cnblogs.com/myseries/p/11801097.html
	主要是理解bean的初始化过程中的三级缓存机制
	https://cloud.tencent.com/developer/article/1497692
#####15.	对Spring IOC 容器的依赖注入的理解？
#####16.	说说对Spring IOC 的单例模式和高级特性？
#####17.	BeanFactory 和 FactoryBean 有什么区别？
#####18.	BeanFactory 和 ApplicationContext 又有什么不同？
	BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。
	BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。
	BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。
	BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。
	从表面上看，ApplicationContext 如同 BeanFactory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 ApplicationContext 在此基础上还提供了其他的功能：
	提供了支持国际化的文本消息
	统一的资源文件读取方式
	已在监听器中注册的 bean 的事件
#####19.	Spring 在 Bean 创建过程中是如何解决循环依赖的？
#####20.	谈谈Spring Bean 创建过程中的设计模式？
#####21.	Spring的IOC容器初始化流程
#####22.	Spring的IOC容器实现原理，为什么可以通过byName和ByType找到Bean
#####23.	Spring AOP实现原理

### 二、多线程
#### 2.1 基本概念
#####1.	多线程并发和并行？
	线程并发，CPU切换，微观上交替执行，宏观上是同时执行；线程并行，真正意义上的并行，多CPU同时执行，无论微观还是宏观都是同时执行。
	⾕歌著名⼯程师罗布·派克（Rob Pike）说过，“并发就是同时应对 （Dealing With）多件事情的能⼒，并⾏是同时执⾏（Doing）多件事情的 能⼒”。这句话⾮常透彻地阐述了并发和并⾏的区别，在于“应对”和“执 ⾏”。
	解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。
	解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件
#####2. IO密集型 和CPU密集型任务
	根据任务所需要的cpu和io资源的量可以分为CPU密集型任务:  主要是执行计算任务，响应时间很快，cpu一直在运行，这种任务cpu的利用率很高
	IO密集型任务：主要是进行IO操作，执行IO操作的时间较长，这是cpu出于空闲状态，导致cpu的利用率不高
	为了合理最大限度的使用系统资源同时也要保证的程序的高性能，可以给CPU密集型任务和IO密集型任务配置一些线程数。
	CPU密集型：线程个数为CPU核数。这几个线程可以并行执行，不存在线程切换到开销，提高了cpu的利用率的同时也减少了切换线程导致的性能损耗
	IO密集型：线程个数为CPU核数的两倍。到其中的线程在IO操作的时候，其他线程可以继续用cpu，提高了cpu的利用率 
	线程是否越多越好？ 分析如下：
	一个计算为主的程序（专业一点称为CPU密集型程序）。多线程跑的时候，可以充分利用起所有的cpu核心，比如说4个核心的cpu,开4个线程的时候，可以同时跑4个线程的运算任务，此时是最大效率。
	但是如果线程远远超出cpu核心数量 反而会使得任务效率下降，因为频繁的切换线程也是要消耗时间的。
	因此对于cpu密集型的任务来说，线程数等于cpu数是最好的了。
	如果是一个磁盘或网络为主的程序（IO密集型）。一个线程处在IO等待的时候，另一个线程还可以在CPU里面跑，有时候CPU闲着没事干，所有的线程都在等着IO，这时候他们就是同时的了，而单线程的话此时还是在一个一个等待的。我们都知道IO的速度比起CPU来是慢到令人发指的。所以开多线程，比方说多线程网络传输，多线程往不同的目录写文件，等等。
	此时 线程数等于IO任务数是最佳的。
#####3.线程安全问题
	多个线程对共享资源的操作可能产生的数据污染问题。全局变量、或者局部变量发生逃逸。
	附：逃逸分析（https://www.xttblog.com/?p=3158）
	逃逸分析是一种JVM优化手段，JVM尽量避免太多对象在堆上进行分配，提高垃圾回收效率，未开启逃逸分析，所有对象都必须在堆上进行分配，局部变量只是引用指针。开启逃逸分析之后，-XX:+DoEscapeAnalysis 一些未发生逃逸的局部变量，可以直接在栈上进行分配，方法执行完后，直接回收。
#####4.共享变量的内存可见性问题
	1）多核CPU  多级缓存的MESI协议   CPU级别 L1 L2缓存不被污染  L3共享
	2）内存屏障   多线程级别 并发
	3）指令重排      DCL 失效问题  必须加volatile
	https://blog.csdn.net/mnb65482/article/details/80458571
	变量可见性是指变量在多个线程工作内存和主内存保持一致，一个线程修改了变量，其他线程能够看到发送的状态变化，涉及到指令重排。实现原理是JVM的内存屏障。volatile通过内存屏障和禁止指令重排实现可见性。
	附：指令重排和内存屏障。
	指令重排：代码指令并不是严格按照代码语句的顺序执行，而是采取乱序执行，直接运行当前有能力执行的后续指令，避开获取下一条指令数据所需数据造成的等待，CPU可以大大提高执行效率。As-if-serial语义的意思是，所有的动作(Action)都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的。Java编译器、运行时和处理器都会保证单线程下的as-if-serial语义。为了保证这一语义，重排序不会发生在有数据依赖的操作之中.
	内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。
      内存屏障可以被分为以下几种类型（读屏障、写屏障）
	LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
	StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
	LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
	StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。        在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。
#####5.Java中原子性
	原子性：不被多线程调度机制打断的操作，一旦开始一直到结束，不会切换到其他线程，切换上下文。Java中的CAS操作,AtomicLong实现原理？
	CAS是 compareAndSwap java解决线程同步的乐观锁机制，修改变量的时候检查当前值，符合的话修改成功，否则不做任何操作。
	CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。

#####6.Java中Synchronized关键字的内存语义是什么？
	Synchronized   monitorEnter monitorExit 指令对对象的对象头markWord修改，对象头1bit标识偏向锁状态，2bit标识同步状态。mutex锁修改状态。如果状态是加锁状态，其他线程挂起，重量级锁，是因为引起线程切换。1.6之后优化：
	
#####7.什么是伪共享,为何会出现，以及如何避免？
	false sharing ：不同的线程操作同一个缓存行，导致的竞争冲突。
	详见：https://www.jianshu.com/p/a4358d39adac
 	ConccuentHashMap size底层使用了填充解决伪共享
	CPU缓存是以缓存行为单位进行操作的。产生伪共享问题的根源在于不同的核同时操作同一个缓存行。
	可以通过填充来解决伪共享问题，Java8 中引入了@sun.misc.Contended注解来自动填充。
	并不是所有的场景都需要解决伪共享问题，因为CPU缓存是有限的，填充会牺牲掉一部分缓存。

#####8.可重入锁、乐观锁、悲观锁、公平锁、非公平锁、独占锁、共享锁？
	独占锁：I
	共享锁：S
	ReentrantLock基于aqs实现，他的基本原理是aqs的status为0时表示锁被占用，为1时表示锁被释放。ReentrantLock在使用时需要显式的获取和释放锁，一般用try finally来实现，相对于synchronized，reentrantlock提供了功能更强大的api，例如超时锁、可中断锁、公平锁、非公平锁、非阻塞锁获取等等，ReentrantLock是独占锁，它分为公平锁和非公平锁两种模式，公平锁保证按照获取锁的顺序来得到锁，非公平锁则则可以进行抢占，而像countdownlatch、semaphore等组件是基于共享锁实现的，也就是同一时刻可以有多个线程获取锁，锁的数量由用户指定
	独占公平锁原理：
	调用aqs的lock方法尝试获取锁
	调用上层组件reentrantlock的trylock方法尝试获取同步状态，如果获取成功，则成功获取锁，如果获取失败，则被构造成node节点后，利用cas线程安全的加到同步对列的末尾然后该线程进入自旋状态
	自旋时首先判断前驱节点是否为头节点并且能否成功获取到同步状态，如果都成立，则成功获取锁，如果不成立，则先讲将其前驱节点等待状态设置为signal，然后利用Locksupport挂起，等待前驱线程唤醒当被前驱节点唤醒，且成功回去同步状态后，才成功获取到了锁。对于释放锁，就是通过aqs设置同步状态为1的过程，同时唤醒后继节点
	独占非公平锁：
	独占非公平锁与公平锁的唯一区别是，在获取锁时，不管是否有线程在等待锁，直接通过aqs修改同步状态，进行锁抢占，如果抢占失败，那后面的流程就与公平锁一致了。
	共享锁原理：
	共享锁的基本流程与独占锁相同，主要区别在于判断锁获取的条件上，由于是共享锁，也就允许多个线程同时获取，所以同步状态的数量同时的大于1的，如果同步状态为非0，则线程就可以获取锁，只有当同步状态为0时，才说明共享数量的锁已经被全部获取，其余线程只能等待。共享锁的释放过程正好与之相反，释放锁对应的AQS操作时增加同步状态的值。
	补充：锁的四种状态：偏向锁、轻量级锁、重量级锁、无锁
	偏向锁：对象头markWord记录占用锁的线程Id，下次占用会比较线程id，如果是，直接锁定，如果不是，进入轻量级锁，竞争资源。其实是消除线程同步，当做是给一个线程使用的资源。标准解释：线程在大多数情况下并不存在竞争条件，使用同步会消耗性能，而偏向锁是对锁的优化，可以消除同步，提升性能。当一个线程获得锁，会将对象头的锁标志位设为01,进入偏向模式.偏向锁可以在让一个线程一直持有锁，在其他线程需要竞争锁的时候，再释放锁。	
	轻量级锁：大部分资源都是快速释放，避免进入到系统内核级别的线程切换，采用CAS自旋，不挂起，不让出CPU，消耗CPU，等待一会即可。标准解释：当线程A获得偏向锁后，线程B进入竞争状态，需要获得线程A持有的锁，那么线程A撤销偏向锁，进入无锁状态。线程A和线程B交替进入临界区，偏向锁无法满足，膨胀到轻量级锁，锁标志位设为00。	
	重量级锁：竞争激烈，多个线程同时竞争资源，进入线程阻塞。标准解释：当多线程交替进入临界区，轻量级锁hold得住。但如果多个线程同时进入临界区，hold不住了，膨胀到重量级锁	
	见https://www.jianshu.com/p/0f44e797cdd9

#####9. ThreadLocal 的实现原理
	线程独享副本 .  利用线程Thread内部维护的ThreadLocalMap存储每个线程维护的ThreadLocal对象map  key为ThreadLocal对象，value为值。
	ThreadLocal 作为变量的线程隔离方式，其内部是如何做的？
	详见https://www.jianshu.com/p/69ae8c213b30  讲的可以	
	特别注意的是，ThreadLocalMap的Entry是弱引用，存在垃圾回收误区，不会被GC，只有get,set,remove,remove,rehash时候会把判断置空，所以必须显示的remove ThreadLocal对象。
	https://www.toutiao.com/a6560547865880429070/
	摘自详细解释：上文也提到了，Entry继承自WeakReference，大家都知道WeakReference（弱引用）的特性，只要从根集出发的引用中没有有效引用指向该对象，则该对象就可以被回收，这里的有效引用并不包含WeakReference，所以弱引用不影响对象被GC。
	这里被WeakReference引用的对象是哪个呢？可以看Entry的构造方法，很容易看出指的是ThreadLocal自身，也就是说ThreadLocal自身的回收不受ThreadLocalMap的这个弱引用的影响，让用户减轻GC的烦恼。
	但是不用做些什么吗？这么简单？其实不然，ThreadLocalMap还做了其他的工作，试想一下，ThreadLocal对象如果外界没有有效引用，是能够被GC，但是Entry呢？Entry也能自动被GC吗，当然不行，Entry还被ThreadLocalMap的table数组强引用着呢。
	所以ThreadLocalMap该做点什么？我看看ThreadLocalMap的expungeStaleEntry这个方法，这个方法在ThreadLocalMap get、set、remove、rehash等方法都会调用到，看下面标红的两处代码，第一处是将remove的entry赋空，第二次处是找到已经被GC的ThreadLocal，然后会清理掉table数组对entry的引用。这样entry在后续的GC中就会被回收。
	关于强引用、弱引用、软引用
	详见https://www.jianshu.com/p/86efa167a627
	1，强引用。特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。
    2，软引用。特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。
	   应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。
	常见场景：图片缓存。
	3，弱引用。弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
	应用场景：弱应用同样可用于内存敏感的缓存。
	常见场景：handler的使用防止内存泄露。（上图这只是弱引用的例子，handler最好是在activity销毁的时候直接remove掉所有消息）
    4，虚引用。特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
	ReferenceQueue queue = new ReferenceQueue ();
	PhantomReference pr = new PhantomReference (object, queue); 
	程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。
	应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。

#####10. CyclicBarrier内部的实现与 CountDownLatch 区别
	CyclicBarrier底层基于AQS的RetrantLock，   CountDownLatch直接基于AQS，共享锁。CyclicBarrier可以循环使用，CountDownLatch使用一次，计数器到0停止
	https://segmentfault.com/a/1190000014818613

#####11.随机数生成器 Random 类如何使用 CAS 算法保证多线程下新种子的唯一性？
	Random和ThreadLocalRandom
	AtomicLong + CAS .
	Random下，不同的线程会同时对seed更新，产生共享资源竞争，采用的CAS算法会导致自旋。为解决该问题，产生ThreadLocalRandom
	https://www.iteye.com/blog/pzh9527-2428066
	
#####12. ThreadLocalRandom 是如何利用 ThreadLocal 的原理来解决 Random 的局限性？
	https://www.iteye.com/blog/pzh9527-2428066
	1.7和1.8实现有不同
#####13.Spring 框架中如何使用 ThreadLocal 实现 request scope 作用域 Bean？
	https://blog.csdn.net/weixin_34344677/article/details/89722447
	简单来说，利用InheritableThreadLocal，继承父线程的变量属性

#####14.并发包中锁的实现底层（对AQS的理解）？
	https://www.jianshu.com/p/c0afad4e5064
	简单来说，AQS底层是一个volitile 的锁状态state和一个双向队列CLH组成，当一个线程获得资源，state置为1，并将占用线程（有效线程）置为自己，如果资源已经被锁，加入到CLS队列尾部，阻塞等待被唤醒（阻塞之前有一次的CAS，毕竟阻塞的成本较大）。底层使用的模板方法设计模式，本身属于抽象类。
#####15.讲讲独占锁 ReentrantLock 原理？

#####16. 谈谈读写锁 ReentrantReadWriteLock 原理？
	
#####17. StampedLock 锁原理的理解？
	StampedLock 的性能之所以比 ReadWriteLock 还要好，其关键是 StampedLock 支持乐观读的方式。ReadWriteLock 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；而 StampedLock 提供的乐观读，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。
#####18. 谈下对基于链表的非阻塞无界队列 ConcurrentLinkedQueue 原理的理解？
#####19. oncurrentLinkedQueue 内部是如何使用 CAS 非阻塞算法来保证多线程下入队出队操作的线程安全？
#####20. 基于链表的阻塞队列 LinkedBlockingQueue 原理。
	https://www.jianshu.com/p/cc2281b1a6bc
	ArrayBlockingQueue由于其底层基于数组，并且在创建时指定存储的大小，在完成后就会立即在内存分配固定大小容量的数组元素，因此其存储通常有限，故其是一个“有界“的阻塞队列；而LinkedBlockingQueue可以由用户指定最大存储容量，也可以无需指定，如果不指定则最大存储容量将是Integer.MAX_VALUE，即可以看作是一个“无界”的阻塞队列，由于其节点的创建都是动态创建，并且在节点出队列后可以被GC所回收，因此其具有灵活的伸缩性。但是由于ArrayBlockingQueue的有界性，因此其能够更好的对于性能进行预测，而LinkedBlockingQueue由于没有限制大小，当任务非常多的时候，不停地向队列中存储，就有可能导致内存溢出的情况发生。
	其次，ArrayBlockingQueue中在入队列和出队列操作过程中，使用的是同一个lock，所以即使在多核CPU的情况下，其读取和操作的都无法做到并行，而LinkedBlockingQueue的读取和插入操作所使用的锁是两个不同的lock，它们之间的操作互相不受干扰，因此两种操作可以并行完成，故LinkedBlockingQueue的吞吐量要高于ArrayBlockingQueue。
	https://baijiahao.baidu.com/s?id=1659586116326532964&wfr=spider&for=pc
	Java中的BlockingQueue主要有两种实现，分别是ArrayBlockingQueue 和 LinkedBlockingQueue。
	ArrayBlockingQueue是一个用数组实现的有界阻塞队列，必须设置容量。
	LinkedBlockingQueue是一个用链表实现的有界阻塞队列，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。
	这里的问题就出在：不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。也就是说，如果我们不设置LinkedBlockingQueue的容量的话，其默认容量将会是Integer.MAX_VALUE。而newFixedThreadPool中创建LinkedBlockingQueue时，并未指定容量。此时，LinkedBlockingQueue就是一个无边界队列，对于一个无边界队列来说，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出问题。
	看阿里巴巴开发手册并发编程这块有一条：线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式。
#####21. 阻塞队列LinkedBlockingQueue 内部是如何使用两个独占锁 ReentrantLock 以及对应的条件变量保证多线程先入队出队操作的线程安全？
	reetrantLock  takeLock  putLock   
    condition   notEmpty  notFull  
#####22. Semaphore 的内部实现是怎样的？
#####23. 并发组件CopyOnWriteArrayList 是如何通过写时拷贝实现并发安全的 List？
#####24 其他
	1.生产消费者
	2.wait  notify  sleep  
	3.交替打印
	关于线程状态
	NEW  —》RUNABLE -》BLOCKED
                    -》WAITING      TIME_WAITING  
                    -》TERMINATE
	遇到同步方法时候进入blocked
	获取锁，失败，进入重量级锁，会进入waiting 或者time waiting （加入超时时间）
	对象头 重量级锁会记录 monitor对象指针，monitor对象：
	Monitor对象
	每个对象都有一个Monitor对象相关联，Monitor对象中记录了持有锁的线程信息、等待队列等。Monitor对象包含以下三个字段：
	•	_owner 记录当前持有锁的线程
	•	_EntryList 是一个队列，记录所有阻塞等待锁的线程
	•	_WaitSet 也是一个队列，记录调用 wait() 方法并还未被通知的线程
	当线程持有锁的时候，线程id等信息会拷贝进owner字段，其余线程会进入阻塞队列entrylist，当持有锁的线程执行wait方法，会立即释放锁进入waitset，当线程释放锁的时候，owner会被置空，公平锁条件下，entrylist中的线程会竞争锁，竞争成功的线程id会写入owner，其余线程继续在entrylist中等待。

#####25. 开启线程的三种方式？
#####26. 线程和进程的区别？
#####27. 为什么要有线程，而不是仅仅用进程？
#####28. run()和start()方法区别
#####29. 如何控制某个方法允许并发访问线程的个数？
#####30. 在Java中wait和seelp方法的不同；
#####31. 谈谈wait/notify关键字的理解
#####32. 什么导致线程阻塞？
#####33. 线程如何关闭？
#####34. 讲一下java中的同步的方法
#####35. 数据一致性如何保证？
#####36. 如何保证线程安全？
#####37. 如何实现线程同步？
#####38. 两个进程同时要求写或者读，能不能实现？如何防止进程的同步？
#####39. 线程间操作List
#####40. Java中对象的生命周期
#####41. Synchronized用法 synchronize的原理
#####42. 谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解
#####43. static synchronized 方法的多线程访问和作用
#####44. 同一个类里面两个synchronized方法，两个线程同时访问的问题
#####45. volatile的原理
#####46. 谈谈volatile关键字的用法
#####47. 谈谈volatile关键字的作用
#####48. 谈谈NIO的理解
#####49. synchronized与Lock的区别
#####50. ReentrantLock 、synchronized和volatile比较
#####51. ReentrantLock的内部实现
#####52. lock原理
#####53. 死锁的四个必要条件？
#####54. 怎么避免死锁？
#####55. 对象锁和类锁是否会互相影响？
#####56. 什么是线程池，如何使用?
#####57. Java的并发、多线程、线程模型
#####58. 如何保证多线程读写文件的安全？
#####59. 多线程断点续传原理
#####60. 断点续传的实现

###三、JVM
####3.1 基本概念
#####1.	Java 内存分配？
#####2.	Java 堆的结构是什么样子的？
#####3.	什么是堆中的永久代（Perm Gen space）?
	metaspace perm 比较
	metaspace是分配在直接内存中（堆外），不指定大小的话，默认系统内存大小，直到耗尽内存。不参与垃圾回收，不会抛出perm OOM异常，但是如果指定了大小，超过最大大小，会触发GC
    PermGen的劣势
	•	固定的PermSize，大小很难确定并且很难进行扩展
	•	    -XX:MaxPermSize
	•	    -XX:PermSize
	•	在进行full GC时PermGen中的class meta对象有可能会被移动
	•	发生java.lang.OutOfMemoryError: PermGen error时
	•	    应用程序要清除与class关联的所有引用
	•	    要么更改MaxPermSize重启应用
	•	需要meta-classmeta对象对classmeta对象进行描述
	•		垃圾回收效率较低，需要进行对整个PermGen进行扫描
    Metaspace的优势
	•	类和类元数据的生命周期与类加载器一致
		•	Metaspace的空间分配是线性的，可随类加载的数量进行线性的扩展，默认情况下只与native memory大小有关
	•	元数据的位置在native memory中的位置是固定的
	•	GC时不会对metaspace空间进行扫描，节省了扫描和压缩的时间(如果设置了Metaspace的大小，当到达该Metaspace的阀值也会进行full GC)
	•	减小了full gc的时间
#####4.	说说各个区域的作用？
#####5.	Java 中会存在内存泄漏吗，简述一下？
#####6.	Java 类加载过程？
#####7.	描述一下 JVM 加载 Class 文件的原理机制?
#####8.	什么是类加载器？
#####9.	类加载器有哪些？
#####10.	什么是tomcat类加载机制？
#####11.	类加载器双亲委派模型机制？
#####12.	什么是GC? 为什么要有 GC？
#####13.	简述一下Java 垃圾回收机制？
#####14.	如何判断一个对象是否存活？
     GC Roots  
	1.虚拟机栈（本地变量表）引用的对象
	2.方法区静态属性引用的对象
	3.方法区常量引用的对象
	4.本地方法栈JNI（一般指naive方法）中引用的对象
#####15.	垃圾回收的优点和原理，并考虑 2 种回收机制？
#####16.	垃圾回收器的基本原理是什么？
	CMS  G1垃圾回收
    初始标记  并发标记 重新标记  并发清理
	G1垃圾回收器是主要针对多处理器以及大内存的机器，以极高的概率满足预测GC停顿时间要求的同时，还具备高吞吐量性能特征。是基于标记整理的垃圾回收器
	记忆集Rset https://www.jianshu.com/p/24a884fa3977
	https://www.jianshu.com/p/78e2d8579935
#####17.	垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
#####18.	深拷贝和浅拷贝？
	浅拷贝   引用类型，只是复制地址，改变会影响原件的变化
	深拷贝  真正的内容复制
#####19.	System.gc() 和 Runtime.gc() 会做些什么？
	java.lang.System.gc()只是java.lang.Runtime.getRuntime().gc()的简写，两者的行为没有任何不同
	•	System.gc()和runtime.gc()用于提示jvm进行垃圾回收，但是否立即回收还是延迟回收由java虚拟机决定
	System.gc(); //告诉垃圾收集器打算进行垃圾收集，而垃圾收集器进不进行收集是不确定的
	https://blog.csdn.net/qq_32534441/article/details/94989683
#####20.	什么是分布式垃圾回收（DGC）？它是如何工作的？
#####21.	串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
#####22.	在 Java 中，对象什么时候可以被垃圾回收？
	无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析判断对象的引用链是否可达，判断对象是否存活都与“引用”有关。
	在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference） 4 种，这 4 种引用强度一次逐渐减弱。
	•	强引用就是指在程序代码之中普遍存在的，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
	•	软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前（即内存紧张）， 将会把这些对象列进垃圾回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK1.2 之后， 提供了 SoftReference 类累实现软引用。
	•	弱引用是用来描述非必需的对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。 当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。使用 WeekReference 类来实现弱引用。
	•	虚引用也成为幽灵引用或者幻影引用，它是最弱的一种引用。一个对象是否有虚引用的存在，完全不会对其生存周期时间构成影响， 也无法通过虚引用来取得一个对象实例。唯一的作用就是能在这个对象被收集器回收时收到一个系统通知。使用 PhantomReference 表示。
#####23.	简述Minor GC 和 Major GC？
#####24.	Java 中垃圾收集的方法有哪些？
#####25.	讲讲你理解的性能评价及测试指标？
#####26.	常用的性能优化方式有哪些？
	https://www.jianshu.com/p/f57d05247329
	从以下几个方面：
	JAVA代码层面、数据库、架构、缓存、异步等
#####27.	说说分布式缓存和一致性哈希？
#####28.	同步与异步？阻塞与非阻塞？
#####29.	什么是GC调优？
#####30.	常见异步的手段有哪些？


###四、数据库
####1.基本概念
#####1.	MySQL 有哪些存储引擎啊？都有什么区别？
	innoDB  MYISAM	
#####2.	Float、Decimal 存储金额的区别？
	https://www.jianshu.com/p/40bddd5126f9
	Float 二进制 精度6~7位，可能不准确 性能高
	Decimal 十进制保存，更高精度 28位，但性能差
#####3.	Datetime、Timestamp 存储时间的区别？
#####4.	Char、Varchar、Varbinary 存储字符的区别？
#####5.	对比一下B+树索引和 Hash索引？
#####6.	MySQL索引类型有？
	https://www.jianshu.com/p/25911c72f91c
	普通索引、唯一索引、主键索引、联合索引、全文索引
#####7.	如何管理 MySQL索引？
#####8.	对Explain参数及重要参数的理解？
	key  extends  rows
#####9.	索引利弊是什么及索引分类？
#####10.	聚簇索引和非聚簇索引的区别？
#####11.	B+tree 如何进行优化？索引遵循哪些原则？
	一、离散型
	二、最左匹配
	三、联合索引
	四、覆盖索引
#####12.索引与锁有什么关系
	https://www.jianshu.com/p/42c3e34a3367Mysql
		索引使用的数据结构主要有BTree索引 和 哈希索引 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。Mysql的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。InnoDB: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。锁 MyISAM和InnoDB存储引擎使用的锁：
	MyISAM采用表级锁(table-level locking)。
	InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁
表级锁和行级锁对比：
	•	表级锁： Mysql中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
•	行级锁： Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。
	InnoDB存储引擎的锁的算法有三种：
•	Record lock：单个行记录上的锁 
•	Gap lock：间隙锁，锁定一个范围，不包括记录本身 
•	Next-key lock：record+gap 锁定一个范围，包含记录本身 相关知识点：
1.	innodb对于行的查询使用next-key lock
2.	Next-locking keying为了解决Phantom Problem幻读问题
3.	当查询的索引含有唯一属性时，将next-key lock降级为record key
4.	Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
5.	有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1
	innodb 的锁是基于索引做的
#####13.	还有什么其他的索引类型，各自索引有哪些优缺点？
#####14.	谈谈对Innodb事务的理解？
	https://www.jianshu.com/p/9b83ea78b380
	redoLog undoLog
#####15.	说说数据库事务特点及潜在问题？
	ACID 
#####16.	什么是MySQL隔离级别？
#####17.	有多少种事务失效的场景，如何解决？
#####18.	一致性非锁定读和一致性锁定读是什么？
#####19.	Innodb如何解决幻读？
	InnoDB默认的隔离级别是RR（可重复读），可以解决脏读和不可重复读，但是不能解决幻读问题。什么是幻读？事务A读取了一个范围内的数据，此时事务B在该范围内插入了一条数据，并立马提交了事务，此时事务A再次读取这个范围的数据时，发现多了一条，就好像幻觉一样。
	什么是MVCC？
	多版本并发控制。InnoDB为每行记录添加了一个版本号（系统版本号），每当修改数据时，版本号加一。
	在读取事务开始时，系统会给事务一个当前版本号，事务会读取版本号<=当前版本号的数据，这时就算另一个事务插入一个数据，并立马提交，新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。
	https://www.jianshu.com/p/70816d3c244c
	https://www.cnblogs.com/fanguangdexiaoyuer/p/10759746.html
	总结：
	Mysql 默认RR级别   传统的RR是避免不可重复读，但不能避免幻读，mysql通过MVCC 避免不可重复度，MVCC的间隙锁 避免幻读
#####20.	讲讲Innodb行锁？
#####21.	死锁及监控是什么？
#####22.	自增长与锁 ，锁的算法，锁问题，锁升级是什么？
#####23.	乐观锁的线程如何做失败补偿？
#####24.	高并发场景（领红包）如何防止死锁，保证数据一致性？
#####25.	谈谈MySQL的锁并发？
#####26 Count 相关
	从执行结果来说：
	count（1）和count（*）之间没有区别，因为count（*）count（1）都不会去过滤空值，
	但count（列名）就有区别了，因为count（列名）会去过滤空值。
	从执行效率来说：
	 他们之间根据不同情况会有些许区别，MySQL会对count（*）做优化。

         （1）如果列为主键，count(列名)效率优于count(1)  

         （2）如果列不为主键，count(1)效率优于count(列名)  

         （3）如果表中存在主键，count(主键列名)效率最优  

         （4）如果表中只有一列，则count(*)效率最优  

          （5）如果表有多列，且不存在主键，则count(1)效率优于count(*)

	补充关于count（1）count（*）原理 引用百度知道专业回答
	count(1)，其实就是计算一共有多少符合条件的行。
	1并不是表示第一个字段，而是表示一个固定值。
	其实就可以想成表中有这么一个字段，这个字段就是固定值1，count(1)，就是计算一共有多少个1.
	count(*)，执行时会把星号翻译成字段的具体名字，效果也是一样的，不过多了一个翻译的动作，比固定值的方式效率稍微低一些。


###五、缓存
####1. 基本概念
#####1.	redis数据结构有哪些？
#####2.	Redis缓存穿透，缓存雪崩？
#####3.	如何使用Redis来实现分布式锁？
#####4.	Redis的并发竞争问题如何解决？
#####5.	Redis持久化的几种方式，优缺点是什么，怎么实现的？
#####6.	Redis的缓存失效策略？
#####7.	Redis集群，高可用，原理？
#####8.	Redis缓存分片？
#####9.	Redis的数据淘汰策略？
#####10.	redis队列应用场景？
#####11.	分布式使用场景（储存session）？

###六、网络编程
####1.基本概念
#####1.	TCP建立连接和断开连接的过程？
#####2.	HTTP协议的交互流程，HTTP和HTTPS的差异，SSL的交互流程？
#####3.	TCP的滑动窗口协议有什么用？
#####4.	HTTP协议都有哪些方法？
#####5.	Socket交互的基本流程？
#####6.	讲讲tcp协议（建连过程，慢启动，滑动窗口，七层模型）？
#####7.	webservice协议（wsdl/soap格式，与restt办议的区别）？
#####8.	说说Netty线程模型，什么是零拷贝？
#####9.	TCP三次握手、四次挥手？
#####10.	DNS解析过程？
#####11.	TCP如何保证数据的可靠传输的？


###七、分布式
####1.基本概念
#####1.	什么是CAP定理？
#####2.	说说CAP理论和BASE理论？
#####3.	什么是最终一致性？最终一致性实现方式？
#####4.	什么是一致性Hash？
#####5.	讲讲分布式事务？
	事务的操作位于不同的节点，不同的数据库上，要保持事务的ACID特性。  模块的拆分，服务的独立部署等，带来分布式事务问题。
	https://www.jianshu.com/p/3aea2f91a266
	CAP理论和BASE理论
	BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）
	BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。
	BA：（Basically Available ），基本可用。
	基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。
	S：（ Soft State），软状态
	软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。
	E：（Eventually Consistent ），最终一致 
	最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。
	弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。
	ACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性
	方案一：事务消息
	方案二：补偿事务  TCC
	方案三：二阶段协议   2PC ：fascar 更名为seata  3PC   底层数据库接口都遵循XA规范  perpare  commit rollback
	2PC和3PC的比较 https://www.jianshu.com/p/dd6a340e50b2
	二阶段提交还是有几个缺点的：
	1、同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
	2、单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）
	3、数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。
	4、二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。
	与两阶段提交不同的是，三阶段提交有两个改动点。
	1、引入超时机制。同时在协调者和参与者中都引入超时机制。
	2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
	https://blog.csdn.net/huaishu/article/details/93046220
#####6.	如何实现分布式锁？
#####7.	如何实现分布式 Session?
#####8.	如何保证消息的一致性?
#####9.	负载均衡的理解？
#####10.	正向代理和反向代理？
#####11.	CDN实现原理？
#####12.	怎么提升系统的QPS和吞吐？
#####13.	Dubbo的底层实现原理和机制？
#####14.	描述一个服务从发布到被消费的详细过程？
#####15.	分布式系统怎么做服务治理？
#####16.	消息中间件如何解决消息丢失问题？
#####17.	Dubbo的服务请求失败怎么处理？
#####18.	对分布式事务的理解？
#####19.	如何实现负载均衡,有哪些算法可以实现?
#####20.	Zookeeper的用途,选举的原理是什么?
#####21.	讲讲数据的垂直拆分水平拆分？
#####22.	zookeeper原理和适用场景？
#####23.	zookeeper watch机制？
#####24.	redis/zk节点宕机如何处理？
#####25.	分布式集群下如何做到唯一序列号？
#####26.	用过哪些MQ,怎么用的,和其他mq比较有什么优缺点,MQ的连接是线程安全的吗？
#####27.	MQ系统的数据如何保证不丢失？
#####28.	列举出能想到的数据库分库分表策略？

#####29.	Zookeeper实现原理，以及选主算法
#####30.	为什么需要配置中心，配置中心如何实现的

#####分布式事务，两阶段提交。
#####如何实现分布式锁
	使用分布式锁，和乐观锁的区别？
	多表关联同时更新的情况，乐观锁容易出现死锁，数据库开销大
	简单来说，有以下几种方案：
	一、数据库，加X排它锁，select for update ；或者利用数据库的唯一键，能插入唯一键，线程即获得锁
	二、ZK
	先有一个锁跟节点，lockRootNode，这可以是一个永久的节点
	客户端获取锁，先在lockRootNode下创建一个顺序的瞬时节点，保证客户端断开连接，节点也自动删除
	调用lockRootNode父节点的getChildren()方法，获取所有的节点，并从小到大排序，如果创建的最小的节点是当前节点，则返回true,获取锁成功，否则，关注比自己序号小的节点的释放动作(exist watch)，这样可以保证每一个客户端只需要关注一个节点，不需要关注所有的节点，避免羊群效应。
	如果有节点释放操作，重复步骤3 ###释放锁 只需要删除步骤2中创建的节点即可
	三、缓存 redis tair
	利用setNx，key为null的时候才设置成功，返回1，其他返回0；注意点：
	1）超时时间设置，避免宕机或者超时等异常导致锁一致被无法释放（缓存没法delete） 2）如果要实现可重入，设置count计数 3）避免超时等异常导致锁被其他线程占用之后，释放锁的时候，释放了其他线程的锁，可加入每个请求唯一id，作为缓存value，只有请求id是当前线程的请求id，才可以删除缓存，释放锁。
#####如何实现分布式Session
#####如何保证消息的一致性
#####负载均衡
#####正向代理（客户端代理）和反向代理（服务器端代理）
#####CDN实现原理
#####怎么提升系统的QPS和吞吐量
#####DNS的实现原理
#####介绍下PAXOS协议
#####介绍下Zookeeper的ZAB协议，如何选举LEADER？如何



###八、JDK基础
####1. java基础面试知识点
#####1. Transient关键字
#####2.Ierator 和 Enumeration 比较
	https://www.jianshu.com/p/e1bed6c84c04
	在Java集合中，我们通常都通过 “Iterator(迭代器)” 或 “Enumeration(枚举类)” 去遍历集合。今天，我们就一起学习一下它们之间到底有什么区别。
	我们先看看 Enumeration.java 和 Iterator.java的源码，再说它们的区别。
	Enumeration是一个接口，它的源码如下：
	Iterator也是一个接口，它的源码如下：
	看完代码了，我们再来说说它们之间的区别。
	(01) 函数接口不同
	Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。
	Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。
	(02) Iterator支持fail-fast机制，而Enumeration不支持。
	Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。
	而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。
	第2部分 Iterator和Enumeration实例
	下面，我们编写一个Hashtable，然后分别通过 Iterator 和 Enumeration 去遍历它，比较它们的效率。代码如下：

	从中，我们可以看出。Enumeration 比 Iterator 的遍历速度更快。为什么呢？
	这是因为，Hashtable中Iterator是通过Enumeration去实现的，而且Iterator添加了对fail-fast机制的支持；所以，执行的操作自然要多一些。

#####3. java是值传递的
	在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。只是在传递过程中如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。
#####4. java中==和equals和hashCode的区别
#####5. int、char、long各占多少字节数
#####6. int与integer的区别
#####7. 探探对java多态的理解
#####8. 面对接口  DIP
#####9. String、StringBuffer、StringBuilder区别
#####10. 什么是内部类？内部类的作用
#####11. 抽象类和接口区别
#####12. 抽象类的意义
#####13. 抽象类与接口的应用场景
#####14. 抽象类是否可以没有方法和属性？
#####15. 接口的意义
#####16. 泛型中extends和super的区别
#####17. 父类的静态方法能否被子类重写
#####18. 进程和线程的区别
#####19. final，finally，finalize的区别
#####20. 序列化的方式
#####21. Serializable 和Parcelable 的区别
#####22. 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？
#####23. 静态内部类的设计意图
#####24. 成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用
#####25. 谈谈对kotlin的理解
#####26. 闭包和局部内部类的区别
#####27. string 转换成 integer的方式及原理
####2、 java深入源码级的面试题（有难度）
#####1. 哪些情况下的对象会被垃圾回收机制处理掉？
#####2. 讲一下常见编码方式？
#####3. utf-8编码中的中文占几个字节；int型几个字节？
#####4. 静态代理和动态代理的区别，什么场景使用？
#####5. Java的异常体系
#####6. 谈谈你对解析与分派的认识。
#####7. 修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？
#####8. Java中实现多态的机制是什么？
#####9. 如何将一个Java对象序列化到文件里？
#####10. 说说你对Java反射的理解
#####11. 说说你对Java注解的理解
#####12. 说说你对依赖注入的理解
#####13. 说一下泛型原理，并举例说明
#####14. Java中String的了解
#####15. String为什么要设计成不可变的？
#####16. Object类的equal和hashCode方法重写，为什么？
#####17 常用数据结构简介
#####18. 并发集合了解哪些？
#####19. 列举java的集合以及集合之间的继承关系
#####20. 集合类以及集合框架
#####21. 容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 Java容器类）
#####22. List,Set,Map的区别
#####23. List和Map的实现方式以及存储方式
#####24. HashMap的实现原理
#####25. HashMap数据结构？
#####26. HashMap源码理解
#####27. HashMap如何put数据（从HashMap源码角度讲解）？
#####28. HashMap怎么手写实现？
#####29. ConcurrentHashMap的实现原理
#####30. ArrayMap和HashMap的对比
#####31. HashTable实现原理
#####32. TreeMap具体实现
#####33. HashMap和HashTable的区别
#####34. HashMap与HashSet的区别
#####35. HashSet与HashMap怎么判断集合元素重复？
#####36. 集合Set实现Hash怎么防止碰撞
#####37. ArrayList和LinkedList的区别，以及应用场景
#####38. 数组和链表的区别
#####39. 二叉树的深度优先遍历和广度优先遍历的具体实现
#####40. 堆的结构
#####41. 堆和树的区别
#####42. 堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？
#####43. 什么是深拷贝和浅拷贝
#####44. 手写链表逆序代码
#####45. 讲一下对树，B+树的理解
#####46. 讲一下对图的理解
#####47. 判断单链表成环与否？
#####48. 链表翻转（即：翻转一个单项链表）
#####49. 合并多个单有序链表（假设都是递增的）


###九、架构
####1.DDD
	DDD实践
	界限上下文
	聚合
	聚合根对象的创建不应该被Spring容器管理，也不应该被注入其它对象
	领域实体
	https://www.jianshu.com/p/Tozpp3

	领域服务
	不是属于单个聚合根的业务或者需要多个聚合根配合的业务，放在领域服务中，注意是业务，如果没有业务，协调工作应该放到应用服务中，静态方法放在领域服务中需要通过rpc等其它外部服务处理业务的，放在领域服务中
	领域事件
	防腐
	SIDE-EFFECT-FREE模式和CQRS
#####如何搭建一个高可用系统
#####哪些设计模式可以增加系统的可扩展性
#####介绍设计模式，如模板模式，命令模式，策略模式，适配器模式、桥接模式、装饰模式，观察者模式，状态模式，访问者模式。
#####抽象能力，怎么提高研发效率。
#####什么是高内聚低耦合，请举例子如何实现
#####什么情况用接口，什么情况用消息
#####如果AB两个系统互相依赖，如何解除依赖
#####	如何写一篇设计文档，目录是什么
#####什么场景应该拆分系统，什么场景应该合并系统
#####系统和模块的区别，分别在什么场景下使用

####编程原则：
	SOLID
	接口隔离原则：https://www.jianshu.com/p/4ce9db323348
#####责任链模式
	https://www.bbsmax.com/A/D854XAx35E/
	在Netty里，pipeline中维护了一个handler的链表。每当事件触发时，就会从双向链表的头部(对于downstream事件则是尾部)开始遍历，这样每个handler都会对事件进行处理。在handler里，可以根据事件类型做相应的处理后传至下一个handler继续处理(甚至可以截断处理链)。
	需要注意的是，单次流程是在一个线程中实现的，是串行的。因此如果其中一个handler是阻塞的，就会影响整体的效果。
	当然netty也已经提供了解决方案，可以通过继承ExecutionHandler的handler来处理这类耗时的操作
	关于责任链模式
	优点降低耦合度。它将请求的发送者和接收者解耦简化了对象，使得对象不需要知道链的结构增强给对象指派职责的灵活性，允许动态地新增或者删除责任链增加新的请求处理类方便
	缺点不能保证请求一定被接收；系统性能将受到一定影响，调试时不方便，可能会造成循环调用，上下文模糊，Handler一定要串行，并行滥用，可读性差。及时调整。
####2. 可用性
	容错机制：
	1.failover：失效转移
	Fail-Over的含义为“失效转移”，是一种备份操作模式，当主要组件异常时，其功能转移到备份组件。其要点在于有主有备，且主故障时备可启用，并设置为主。如Mysql的双Master模式，当正在使用的Master出现故障时，可以拿备Master做主使用
	2.failfast：快速失败
	从字面含义看就是“快速失败”，尽可能的发现系统中的错误，使系统能够按照事先设定好的错误的流程执行，对应的方式是“fault-tolerant（错误容忍）”。以JAVA集合（Collection）的快速失败为例，当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常（发现错误执行设定好的错误的流程），产生fail-fast事件。
	具体分析 https://blog.csdn.net/fan2012huan/article/details/51076970
	ArrayList 使用自身的remove ：会修改modCount（修改记录数）导致expertModCount和	modCount不等
	使用Iterator 的remove 会修改modCount 并将expertModCount置为modCount，所以单线程下不会导致ConcurrentModificationException，但是多线程下，仍然会有可能导致ConcurrentModificationException。  
	Fastfail 提供的是一种快速检测失败机制
	3.failback：失效自动恢复
	Fail-over之后的自动恢复，在簇网络系统（有两台或多台服务器互联的网络）中，由于要某台服务器进行维修，需要网络资源和服务暂时重定向到备用系统。在此之后将网络资源和服务器恢复为由原始主机提供的过程，称为自动恢复
	4.failsafe：失效安全
	Fail-Safe的含义为“失效安全”，即使在故障的情况下也不会造成伤害或者尽量减少伤害。维基百科上一个形象的例子是红绿灯的“冲突监测模块”当监测到错误或者冲突的信号时会将十字路口的红绿灯变为闪烁错误模式，而不是全部显示为绿灯。 
####Java SPI
	https://www.cnblogs.com/yaowen/p/10839507.html
	利用了线程上下文ClassLoader
	2.线程上下文类加载器的重要性：
	SPI（Service Provider Interface，服务提供者接口，指的是JDK提供标准接口，具体实现由厂商决定。例如sql）
	父ClassLoader可以使用当前线程Thread.current.currentThread().getContextClassLoader()所指定的classLoader加载的类。这就改变了父ClassLoader不能使用子ClassLoader加载的类的情况，即改变了双亲委托模型。
	线程上下文类加载器就是当前线程的CurrentClassloader
####ClassLoader 
	NoClassDefFoundError vs ClassNotFoundException 
	nice slide of all differences between java.lang.NoClassDefFoundError and java.lang.ClassNotFoundException in Java
	ClassLoader 核心的loadClass与findClass 
	loadClass里面调用findClass，如果自定义的方法不想违背双亲委派模型，则只需要重写findclass方法即可，如果想违背双亲委派模型，则还需要重写loadclass方法。

####限流
	一是 QPS    二是并发线程数	
	降级预案  灰度  流量
	Sentinel使用的是滑动窗口算法
####缓存
#####缓存一致性问题：
	先删除缓存，更新数据库，然后监听数据库binlog，再次删除缓存（双删）
	https://blog.csdn.net/koli6678/article/details/88202245
	缓存击穿、雪崩问题：
	1、缓存穿透
	访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。
	解决方案
	（1）采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；
	（2）拦截器，id<=0的直接拦截。
	（3）从cache和db都取不到，可以将key-value写为key-null，设置较短过期时间，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。
#####缓存击穿
	一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。
	解决方案
	（1）设置热点数据永远不过期。
	（2）加互斥锁。
#####缓存雪崩
      大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。
	解决方案
	（1）缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
	（2）如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
	（3）设置热点数据永远不过期。
	多级缓存：主要是解决热点数据问题，  没使用到，可以提。 多级缓存的一致性，多核CPU的MESI  https://www.cnblogs.com/z00377750/p/9180644.html
	多级缓存，本地缓存的更新   强制接口SDK更新
	缓存预热     热点缓存数据比较多，可以提前预热.  
	场景：缓存验证码次数，超时时间; 配置数据
####消息队列
####分布式调度
####流程引擎
JBPM  Activiti  Spring stateMachine 

###十、基本编程练习
####1.IO 
#####字符流和字节流有什么区别？
	要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。
	字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串；而字节流处理单元为1个字节，操作字节和字节数组。所以字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，如果是音频文件、图片、歌曲，就用字节流好点（避免数据丢失），如果是关系到中文（文本）的，用字符流好点在应用中，经常要完全是字符的一段文本输出去或读进来，用字节流可以吗？计算机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设别写入或读取字符串提供了一点点方便。
	 要么使用字节流向buffer里面读byte然后转string。要么直接使用bufferedReader直接读字符流inputStreamReader的内容

####NIO
	Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。
	在讲 BIO,NIO,AIO 之前先来回顾一下这样几个概念：同步与异步，阻塞与非阻塞。
	同步与异步
	同步：同步就是发起调用之后，被调用这未处理完请求之前，调用不返回
	异步：异步就是发起调用后，立即得到被调用方的回应，但被调用者并没有返回结果，调用方还可以处理其他请求，被调用方依靠事件回调机制通知调用者返回结果
	同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。
	阻塞和非阻塞
	阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续
	非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情
	BIO同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。
	采用 BIO 通信模型 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在 while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。
	如果要让 BIO 通信模型 能够同时处理多个客户端请求，就必须使用多线程（主要原因是 socket.accept()、 socket.read()、 socket.write() 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 一请求一应答通信模型 。我们可以设想一下如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过 线程池机制 改善，线程池还可以让线程的创建和回收成本相对较低。使用FixedThreadPool 可以有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N(客户端请求数量):M(处理客户端请求的线程数量)的伪异步I/O模型（N 可以远远大于 M），下面一节"伪异步 BIO"中会详细介绍到。
	我们再设想一下当客户端并发访问量增加后这种模型会出现什么问题？
	在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。
	伪异步 IO
	为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。
	采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，它的模型图如上图所示。当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。
	伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层任然是同步阻塞的BIO模型，因此无法从根本上解决问题。
	 总结
	在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
	NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。
	NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。
	NIO的特性/NIO与IO区别
	如果是在面试中回答这个问题，我觉得首先肯定要从 NIO 流是非阻塞 IO 而 IO 流是阻塞 IO 说起。然后，可以从 NIO 的3个核心组件/特性为 NIO 带来的一些改进来分析。如果，你把这些都回答上了我觉得你对于 NIO 就有了更为深入一点的认识，面试官问到你这个问题，你也能很轻松的回答上来了。
	1)Non-blocking IO（非阻塞IO）
	IO流是阻塞的，NIO流是不阻塞的。
	Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。
	Java IO的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了
	2)Buffer(缓冲区)
	IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。
	Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。
	在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。
	最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。
	3)Channel (通道)
	NIO 通过Channel（通道） 进行读写。
	通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。
	4)Selectors(选择器)
	NIO有选择器，而IO没有。
	选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。
	NIO 读数据和写数据方式
	通常来说NIO中的所有IO都是从 Channel（通道） 开始的。
	从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据
	从通道进行数据写入：创建一个缓冲区，填充数据，并要求写入通道数据
#####NIO核心组件简单介绍
	NIO 包含下面几个核心的组件：
	Channel（通道）
	Buffer（缓冲区）
	Selector（选择器）
	整个NIO体系包含的类远远不止这三个，只能说这三个是NIO体系的“核心API”。我们上面已经对这三个概念进行了基本的阐述，这里就不多做解释了。
	为什么大家都不愿意用 JDK 原生 NIO 进行开发呢？从上面的代码中大家都可以看出来，是真的难用！除了编程复杂、编程模型难之外，它还有以下让人诟病的问题：
	JDK的NIO底层由epoll实现，该实现饱受诟病的空轮询bug会导致cpu飙升100%。
#####AIO (Asynchronous I/O)
	AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。
	AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。（除了 AIO 其他的 IO 类型都是同步的，这一点可以从底层IO线程模型解释，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。
#####netty事件驱动机制
#####Netty是如何使用线程池的，为什么这么使用
#####NIO的好处,Netty线程模型,什么是零拷贝
	Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，由对应的Handler处理。
	netty 优化粘包问题   https://www.jianshu.com/p/5857d80d9dec
	TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。TCP粘包/分包的原因：
	应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度>MSS的时候将发生拆包
	以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片。
	解决方法
	消息定长：FixedLengthFrameDecoder类
		包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder或自定义分隔符类 ：DelimiterBasedFrameDecoder
	将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。
	netty给我提供了各种方式供我们使用。
	1、DelimiterBasedFrameDecoder是基于消息边界方式进行粘包拆包处理的。
	2、FixedLengthFrameDecoder是基于固定长度消息进行粘包拆包处理的。
	3、LengthFieldBasedFrameDecoder是基于消息头指定消息长度进行粘包拆包处理的。
	4、LineBasedFrameDecoder是基于行来进行消息粘包拆包处理的。
	用户可以自行选择规则然后使用Netty提供的对应的Decoder来进行具有粘包、拆包处理功	能的网络应用开发。
	netty 的zero-copy https://www.jianshu.com/p/69fd6d094771
	Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。堆内存多了一次内存拷贝，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。ByteBuffer由ChannelConfig分配，而ChannelConfig创建ByteBufAllocator默认使用Direct Buffer
	CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。addComponents方法将 header 与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体
	通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。
	通过 wrap方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。
	Selector BUG：若Selector的轮询结果为空，也没有wakeup或新消息处理，则发生空轮询，CPU使用率100%，
	Netty的解决办法：对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数，若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭

###十二、开发性
#####介绍你做过的哪些项目
#####都使用过哪些框架、平台？
#####都使用过哪些自定义控件？
#####研究比较深入的领域有哪些？
#####对业内信息的关注渠道有哪些？
#####最近都读哪些书？
#####有没有什么开源项目？
#####自己最擅长的技术点，最感兴趣的技术领域和技术点
#####项目中用了哪些开源库，如何避免因为引入开源库而导致的安全性和稳定性问题
#####实习过程中做了什么，有什么产出？
#####看过哪些开源框架的源码


#####Hbase存储
